{"stackTrace":[{"type":6,"sourceReference":{"function":"requestNft","contract":"RandomIpfsNFT","sourceName":"contracts/RandomIpfsNFT.sol","sourceContent":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nerror RandomIpfsNFT__RangeOutOfBounce();\r\nerror RandonIpfsNft__NeedMoreETHSend();\r\nerror RandomIpfsNft__TransferFailed();\r\n\r\ncontract RandomIpfsNFT is VRFConsumerBaseV2, ERC721URIStorage, Ownable {\r\n    enum Breed {\r\n        PUG,\r\n        SHIBA_INU,\r\n        ST_BERNARD\r\n    }\r\n    // VRF variables\r\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\r\n    uint64 private immutable i_subscriptionId;\r\n    bytes32 private immutable i_gasLane;\r\n    uint32 private immutable i_callbackGasLimit;\r\n    uint16 private constant REQUEST_CONFORMATIONS = 3;\r\n    uint32 private constant NUM_WORDS = 1;\r\n\r\n    // VRF helper\r\n    mapping(uint256 => address) public s_requestIdToSender;\r\n\r\n    // NFT vairable\r\n    uint256 public s_tokenCounter;\r\n    string[] internal s_dogTokenUri;\r\n    uint256 internal immutable i_mintFee;\r\n\r\n    uint256 internal constant MAX_CHANCE_VALUE = 100;\r\n\r\n    //Events\r\n    event NftRequested(uint256 indexed requestId, address requester);\r\n    event NftMinted(uint256 indexed requestId, Breed DogBreed, address minter);\r\n\r\n    constructor(\r\n        address vrfCoordinatorV2,\r\n        uint64 _subscriptionId,\r\n        bytes32 _gasLane,\r\n        uint32 _callbackGasLimit,\r\n        string[3] memory dogTokenUri,\r\n        uint256 mintFee\r\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) ERC721(\"Random Ipfs NFT\", \"RIN\") {\r\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\r\n        i_subscriptionId = _subscriptionId;\r\n        i_gasLane = _gasLane;\r\n        i_callbackGasLimit = _callbackGasLimit;\r\n        s_dogTokenUri = dogTokenUri;\r\n        i_mintFee = mintFee;\r\n    }\r\n\r\n    function requestNft() public payable returns (uint256 requestId) {\r\n        if (msg.value < i_mintFee) {\r\n            revert RandonIpfsNft__NeedMoreETHSend();\r\n        }\r\n\r\n        requestId = i_vrfCoordinator.requestRandomWords(\r\n            i_gasLane,\r\n            i_subscriptionId,\r\n            REQUEST_CONFORMATIONS,\r\n            
i_callbackGasLimit,\r\n            NUM_WORDS\r\n        );\r\n        s_requestIdToSender[requestId] = msg.sender;\r\n        emit NftRequested(requestId, msg.sender);\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256 requestId,\r\n        uint256[] memory randomWord\r\n    ) internal override {\r\n        address dogOwner = s_requestIdToSender[requestId];\r\n        uint256 newTokenId = s_tokenCounter;\r\n\r\n        uint256 moddedRng = randomWord[0] % MAX_CHANCE_VALUE;\r\n        Breed dogBreed = getBreedFromModdedRng(moddedRng);\r\n        s_tokenCounter += 1;\r\n\r\n        _safeMint(dogOwner, newTokenId);\r\n        _setTokenURI(newTokenId, s_dogTokenUri[uint256(dogBreed)]);\r\n        emit NftMinted(requestId, dogBreed, dogOwner);\r\n    }\r\n\r\n    function getBreedFromModdedRng(\r\n        uint256 moddedRng\r\n    ) public pure returns (Breed) {\r\n        uint256 cumulativeSum = 0;\r\n        uint256[3] memory chanceArray = getArrayChance();\r\n\r\n        for (uint256 i = 0; i < chanceArray.length; i++) {\r\n            if (\r\n                moddedRng >= cumulativeSum &&\r\n                moddedRng < cumulativeSum + chanceArray[i]\r\n            ) {\r\n                return Breed(i);\r\n            }\r\n            cumulativeSum += chanceArray[i];\r\n        }\r\n        revert RandomIpfsNFT__RangeOutOfBounce();\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert RandomIpfsNft__TransferFailed();\r\n        }\r\n    }\r\n\r\n    function getArrayChance() public pure returns (uint256[3] memory) {\r\n        return [10, 30, MAX_CHANCE_VALUE];\r\n    }\r\n\r\n    function getMintFee() public view returns (uint256) {\r\n        return i_mintFee;\r\n    }\r\n\r\n    function getDogTokenUri(uint256 index) public view returns (string memory) {\r\n        return s_dogTokenUri[index];\r\n    }\r\n\r\n    function getTokenCounter() public view returns (uint256) {\r\n        return s_tokenCounter;\r\n    }\r\n}\r\n","line":60,"range":[2093,2125]},"message":"reverted with custom error 'RandonIpfsNft__NeedMoreETHSend()'"}],"data":"0x7262f658","transactionHash":"0xe42a8980d9fa6e6292cd0d074d3106ec3de6107f880b8fd6649f2ef1195cccf3"}
      1) fails if payment isn't sent with the request
error in the call :  {"stackTrace":[{"type":6,"sourceReference":{"function":"requestNft","contract":"RandomIpfsNFT","sourceName":"contracts/RandomIpfsNFT.sol","sourceContent":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nerror RandomIpfsNFT__RangeOutOfBounce();\r\nerror RandonIpfsNft__NeedMoreETHSend();\r\nerror RandomIpfsNft__TransferFailed();\r\n\r\ncontract RandomIpfsNFT is VRFConsumerBaseV2, ERC721URIStorage, Ownable {\r\n    enum Breed {\r\n        PUG,\r\n        SHIBA_INU,\r\n        ST_BERNARD\r\n    }\r\n    // VRF variables\r\n    VRFCoordinatorV2Interface private immutable i_vrfCoordinator;\r\n    uint64 private immutable i_subscriptionId;\r\n    bytes32 private immutable i_gasLane;\r\n    uint32 private immutable i_callbackGasLimit;\r\n    uint16 private constant REQUEST_CONFORMATIONS = 3;\r\n    uint32 private constant NUM_WORDS = 1;\r\n\r\n    // VRF helper\r\n    mapping(uint256 => address) public s_requestIdToSender;\r\n\r\n    // NFT vairable\r\n    uint256 public s_tokenCounter;\r\n    string[] internal s_dogTokenUri;\r\n    uint256 internal immutable i_mintFee;\r\n\r\n    uint256 internal constant MAX_CHANCE_VALUE = 100;\r\n\r\n    //Events\r\n    event NftRequested(uint256 indexed requestId, address requester);\r\n    event NftMinted(uint256 indexed requestId, Breed DogBreed, address minter);\r\n\r\n    constructor(\r\n        address vrfCoordinatorV2,\r\n        uint64 _subscriptionId,\r\n        bytes32 _gasLane,\r\n        uint32 _callbackGasLimit,\r\n        string[3] memory dogTokenUri,\r\n        uint256 mintFee\r\n    ) VRFConsumerBaseV2(vrfCoordinatorV2) ERC721(\"Random Ipfs NFT\", \"RIN\") {\r\n        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinatorV2);\r\n        i_subscriptionId = _subscriptionId;\r\n        i_gasLane = _gasLane;\r\n        i_callbackGasLimit = _callbackGasLimit;\r\n        s_dogTokenUri = dogTokenUri;\r\n        i_mintFee = mintFee;\r\n    }\r\n\r\n    function requestNft() public payable returns (uint256 requestId) {\r\n        if (msg.value < i_mintFee) {\r\n            revert RandonIpfsNft__NeedMoreETHSend();\r\n        }\r\n\r\n        requestId = i_vrfCoordinator.requestRandomWords(\r\n            i_gasLane,\r\n            i_subscriptionId,\r\n            REQUEST_CONFORMATIONS,\r\n            
i_callbackGasLimit,\r\n            NUM_WORDS\r\n        );\r\n        s_requestIdToSender[requestId] = msg.sender;\r\n        emit NftRequested(requestId, msg.sender);\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256 requestId,\r\n        uint256[] memory randomWord\r\n    ) internal override {\r\n        address dogOwner = s_requestIdToSender[requestId];\r\n        uint256 newTokenId = s_tokenCounter;\r\n\r\n        uint256 moddedRng = randomWord[0] % MAX_CHANCE_VALUE;\r\n        Breed dogBreed = getBreedFromModdedRng(moddedRng);\r\n        s_tokenCounter += 1;\r\n\r\n        _safeMint(dogOwner, newTokenId);\r\n        _setTokenURI(newTokenId, s_dogTokenUri[uint256(dogBreed)]);\r\n        emit NftMinted(requestId, dogBreed, dogOwner);\r\n    }\r\n\r\n    function getBreedFromModdedRng(\r\n        uint256 moddedRng\r\n    ) public pure returns (Breed) {\r\n        uint256 cumulativeSum = 0;\r\n        uint256[3] memory chanceArray = getArrayChance();\r\n\r\n        for (uint256 i = 0; i < chanceArray.length; i++) {\r\n            if (\r\n                moddedRng >= cumulativeSum &&\r\n                moddedRng < cumulativeSum + chanceArray[i]\r\n            ) {\r\n                return Breed(i);\r\n            }\r\n            cumulativeSum += chanceArray[i];\r\n        }\r\n        revert RandomIpfsNFT__RangeOutOfBounce();\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert RandomIpfsNft__TransferFailed();\r\n        }\r\n    }\r\n\r\n    function getArrayChance() public pure returns (uint256[3] memory) {\r\n        return [10, 30, MAX_CHANCE_VALUE];\r\n    }\r\n\r\n    function getMintFee() public view returns (uint256) {\r\n        return i_mintFee;\r\n    }\r\n\r\n    function getDogTokenUri(uint256 index) public view returns (string memory) {\r\n        return s_dogTokenUri[index];\r\n    }\r\n\r\n    function getTokenCounter() public view returns (uint256) {\r\n        return s_tokenCounter;\r\n    }\r\n}\r\n","line":60,"range":[2093,2125]},"message":"reverted with custom error 'RandonIpfsNft__NeedMoreETHSend()'"}],"data":"0x7262f658","transactionHash":"0xe42a8980d9fa6e6292cd0d074d3106ec3de6107f880b8fd6649f2ef1195cccf3"}